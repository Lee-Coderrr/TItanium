<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; min-height: 100vh; padding: 20px; }
        .dashboard-container { max-width: 1400px; margin: 0 auto; display: grid; gap: 20px; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .header { grid-column: 1 / -1; text-align: center; padding: 20px; background: rgba(255, 255, 255, 0.1); border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; background: linear-gradient(45deg, #ff6b6b, #4ecdc4); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .widget { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .widget:hover { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .widget h3 { margin-bottom: 15px; font-size: 1.3em; border-bottom: 2px solid rgba(255, 255, 255, 0.3); padding-bottom: 10px; }
        .metric { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; }
        .metric-value { font-size: 1.5em; font-weight: bold; }
        .metric-good { color: #4ade80; } .metric-warning { color: #fbbf24; } .metric-danger { color: #f87171; }
        .chart-container { position: relative; height: 300px; margin-top: 15px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .status-healthy { background-color: #4ade80; } .status-warning { background-color: #fbbf24; } .status-error { background-color: #f87171; }
        .server-list, .alerts-container { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; }
        .server-item, .alert-box { padding: 10px; margin-bottom: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; }
        .server-item { display: flex; justify-content: space-between; align-items: center; }
        .alert-box { border-left: 4px solid; }
        .alert-box.info { border-color: #3b82f6; } .alert-box.warning { border-color: #fbbf24; } .alert-box.error { border-color: #f87171; }
        .controls { display: flex; gap: 10px; margin-bottom: 15px; }
        .control-btn { padding: 8px 16px; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 5px; color: white; cursor: pointer; transition: background 0.3s ease; }
        .control-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .control-btn.active { background: #4ade80; }
        .logs-container { height: 200px; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 10px; font-family: 'Courier New', monospace; font-size: 0.9em; }
        .log-entry { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <h1>ğŸš€ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ V2</h1>
            <p>ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ í´ëŸ¬ìŠ¤í„° í†µí•© ëª¨ë‹ˆí„°ë§</p>
            <div style="margin-top: 10px;">
                <span id="current-time"></span> | <span id="uptime">Uptime: 00:00:00</span>
            </div>
        </div>

        <div class="widget">
            <h3>ğŸ¯ ì‹œìŠ¤í…œ ì „ì²´ ìƒíƒœ</h3>
            <div class="controls">
                <button id="toggle-monitoring-btn" class="control-btn active">ëª¨ë‹ˆí„°ë§ ON</button>
                <button id="refresh-btn" class="control-btn">ìƒˆë¡œê³ ì¹¨</button>
                <button id="reset-stats-btn" class="control-btn">í†µê³„ ì´ˆê¸°í™”</button>
            </div>
            <div class="metric"><span>ì „ì²´ ìƒíƒœ</span><span class="metric-value metric-good" id="overall-status">INITIALIZING</span></div>
            <div class="metric"><span>í™œì„± ì„œë¹„ìŠ¤</span><span class="metric-value" id="active-services">0/0</span></div>
            <div class="metric"><span>ì´ ìš”ì²­ ìˆ˜</span><span class="metric-value" id="total-requests">0</span></div>
            <div class="metric"><span>ì„±ê³µë¥ </span><span class="metric-value metric-good" id="success-rate">100%</span></div>
        </div>

        <div class="widget"><h3>â±ï¸ ì‘ë‹µ ì‹œê°„ ì¶”ì´</h3><div class="chart-container"><canvas id="responseTimeChart"></canvas></div></div>
        <div class="widget"><h3>ğŸ“ˆ ì²˜ë¦¬ëŸ‰ (RPS)</h3><div class="chart-container"><canvas id="throughputChart"></canvas></div></div>

        <div class="widget">
            <h3>ğŸ–¥ï¸ ì„œë²„ ìƒíƒœ</h3>
            <ul class="server-list" id="server-list"></ul>
        </div>

        <div class="widget">
            <h3>ğŸŒ ë„¤íŠ¸ì›Œí¬ í†µê³„</h3>
            <div class="metric"><span>í˜„ì¬ RPS</span><span class="metric-value" id="current-rps">0</span></div>
            <div class="metric"><span>í‰ê·  ì‘ë‹µì‹œê°„</span><span class="metric-value" id="avg-response-time">0ms</span></div>
            <div class="metric"><span>ì—ëŸ¬ìœ¨</span><span class="metric-value" id="error-rate">0%</span></div>
        </div>

        <div class="widget">
            <h3>ğŸš¨ ì•ŒëŒ ë° ì´ë²¤íŠ¸</h3>
            <ul class="alerts-container" id="alerts-container"></ul>
        </div>

        <div class="widget">
            <h3>ğŸ’¾ ë°ì´í„° ì €ì¥ì†Œ ìƒíƒœ</h3>
            <div class="metric"><span>ë°ì´í„°ë² ì´ìŠ¤</span><span class="metric-value metric-good" id="db-status">N/A</span></div>
            <div class="metric"><span>ìºì‹œ íˆíŠ¸ìœ¨</span><span class="metric-value" id="cache-hit-rate">0%</span></div>
            <div class="metric"><span>í™œì„± ì„¸ì…˜</span><span class="metric-value" id="active-sessions">0</span></div>
        </div>

        <div class="widget" style="grid-column: 1 / -1;">
            <h3>ğŸ“ ì‹¤ì‹œê°„ ë¡œê·¸</h3>
            <div class="logs-container" id="logs-container"></div>
        </div>
    </div>

    <script type="module">
        const config = {
            // [ìˆ˜ì •] ëª¨ë“  ìš”ì²­ì€ ë¡œë“œ ë°¸ëŸ°ì„œë¥¼ í†µí•˜ë¯€ë¡œ, ë‹¨ì¼ ì—”ë“œí¬ì¸íŠ¸ë¡œ í†µì¼í•©ë‹ˆë‹¤.
            apiEndpoint: 'http://localhost:7100',
            refreshInterval: 2000,
            maxChartPoints: 30,
            maxLogEntries: 50,
            maxAlerts: 5,
        };

        const eventBus = {
            events: {},
            subscribe(eventName, callback) { if (!this.events[eventName]) this.events[eventName] = []; this.events[eventName].push(callback); },
            publish(eventName, data) { if (this.events[eventName]) this.events[eventName].forEach(callback => callback(data)); }
        };

        const apiService = {
            monitoringEnabled: true,
            fetchIntervalId: null,
            async fetchAllStats() {
                try {
                    // [ìˆ˜ì •] ë‘ ìš”ì²­ ëª¨ë‘ ë‹¨ì¼ apiEndpoint(ë¡œë“œ ë°¸ëŸ°ì„œ)ë¥¼ í†µí•´ í˜¸ì¶œí•©ë‹ˆë‹¤.
                    // ë¡œë“œ ë°¸ëŸ°ì„œì˜ í†µê³„ëŠ” /lb-stats
                    // API ê²Œì´íŠ¸ì›¨ì´ì˜ í†µê³„ëŠ” /stats (ë¡œë“œ ë°¸ëŸ°ì„œê°€ ì•Œì•„ì„œ ì „ë‹¬í•´ ì¤Œ)
                    const [lbResponse, apiResponse] = await Promise.all([
                        fetch(config.apiEndpoint + '/lb-stats'),
                        fetch(config.apiEndpoint + '/stats')
                    ]);

                    if (!lbResponse.ok || !apiResponse.ok) {
                        // 403 ì—ëŸ¬ ë“± ì‘ë‹µì´ ì •ìƒì´ ì•„ë‹ ê²½ìš°ë¥¼ ì²˜ë¦¬
                        if (!lbResponse.ok) console.error('Load Balancer stats fetch failed:', lbResponse.statusText);
                        if (!apiResponse.ok) console.error('API Gateway stats fetch failed:', apiResponse.statusText);
                        throw new Error('Network response was not ok');
                    }

                    const lbStats = await lbResponse.json();
                    const apiStats = await apiResponse.json();
                    eventBus.publish('statsUpdated', { lbStats, apiStats, isFetchSuccess: true });
                } catch (error) {
                    eventBus.publish('fetchError', { error, isFetchSuccess: false });
                }
            },
            async resetAllStats() {
                try {
                    // [ìˆ˜ì •] reset ìš”ì²­ë„ ë¡œë“œ ë°¸ëŸ°ì„œë¥¼ í†µí•´ ê° ì„œë¹„ìŠ¤ë¡œ ì „ë‹¬ë˜ë„ë¡ í•©ë‹ˆë‹¤.
                    // ë¡œë“œ ë°¸ëŸ°ì„œì˜ /reset-stats ì™€ API ê²Œì´íŠ¸ì›¨ì´ì˜ /reset-statsëŠ” ì´ë¦„ì´ ê°™ì§€ë§Œ
                    // ë¡œë“œ ë°¸ëŸ°ì„œê°€ ìì‹ ì˜ ê²ƒì€ ì§ì ‘ ì²˜ë¦¬í•˜ê³ , API ê²Œì´íŠ¸ì›¨ì´ ê²ƒì€ ì „ë‹¬í•´ ì¤„ ê²ƒì…ë‹ˆë‹¤.
                    // (ë‹¨, í˜„ì¬ API ê²Œì´íŠ¸ì›¨ì´ /reset-statsëŠ” ë¡œë“œë°¸ëŸ°ì„œë¥¼ í†µí•´ ë¼ìš°íŒ…ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
                    // lb-stats ì´ˆê¸°í™”ë§Œ í˜¸ì¶œí•˜ê±°ë‚˜, ë¼ìš°íŒ… ê·œì¹™ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” lb-statsë§Œ ì´ˆê¸°í™”)
                    await Promise.all([
                        fetch(config.apiEndpoint + '/reset-stats', { method: 'POST' }),
                        // API Gatewayì˜ resetì€ /api/v1/reset-stats ì™€ ê°™ì´ ë³„ë„ ê²½ë¡œê°€ í•„ìš”í•  ìˆ˜ ìˆìœ¼ë‚˜,
                        // í˜„ì¬ êµ¬ì¡°ì—ì„œëŠ” ë¡œë“œë°¸ëŸ°ì„œê°€ /reset-statsë¥¼ ì§ì ‘ ì²˜ë¦¬í•˜ë¯€ë¡œ ì•„ë˜ ë¼ì¸ì€ ìƒëµí•˜ê±°ë‚˜
                        // ë¡œë“œë°¸ëŸ°ì„œì— ë¼ìš°íŒ… ê·œì¹™ì„ ì¶”ê°€í•´ì•¼ í•¨. ì—¬ê¸°ì„œëŠ” ë¡œë“œë°¸ëŸ°ì„œ ë¦¬ì…‹ë§Œ ìˆ˜í–‰.
                        fetch(config.apiEndpoint + '/reset-stats', { method: 'POST' })
                    ]);
                    return true;
                } catch (error) {
                    console.error('Failed to reset stats:', error);
                    return false;
                }
            },
            start() {
                this.monitoringEnabled = true;
                this.fetchAllStats();
                if (this.fetchIntervalId) clearInterval(this.fetchIntervalId);
                this.fetchIntervalId = setInterval(() => { if (this.monitoringEnabled) this.fetchAllStats(); }, config.refreshInterval);
                eventBus.publish('log', { message: 'Monitoring started.' });
            },
            stop() {
                this.monitoringEnabled = false;
                eventBus.publish('log', { message: 'Monitoring paused.' });
            }
        };

        // ... (ì´í•˜ chartModule, statusModule ë“± ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” ê¸°ì¡´ê³¼ ë™ì¼)
        const chartModule = {
            charts: {},
            init() {
                // [ìˆ˜ì •] ëª¨ë“  ì°¨íŠ¸ê°€ ê¸°ë³¸ ìë™ ìŠ¤ì¼€ì¼ë§ì„ ì‚¬ìš©í•˜ë„ë¡ ê³µí†µ ì˜µì…˜ì„ ë‹¨ìˆœí™”í•©ë‹ˆë‹¤.
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { ticks: { color: '#fff' } },
                        y: { ticks: { color: '#fff' }, beginAtZero: true } // Yì¶•ì´ 0ë¶€í„° ì‹œì‘í•˜ë„ë¡ë§Œ ì„¤ì •
                    }
                };

                // ë‘ ì°¨íŠ¸ ëª¨ë‘ ë™ì¼í•œ ê³µí†µ ì˜µì…˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
                this.charts.responseTime = new Chart(document.getElementById('responseTimeChart')?.getContext('2d'), {
                    type: 'line',
                    data: { labels: [], datasets: [{ data: [], borderColor: '#4ade80', backgroundColor: 'rgba(74,222,128,0.1)', tension: 0.4, fill: true }] },
                    options: commonOptions
                });

                this.charts.throughput = new Chart(document.getElementById('throughputChart')?.getContext('2d'), {
                    type: 'bar',
                    data: { labels: [], datasets: [{ data: [], backgroundColor: '#3b82f6' }] },
                    options: commonOptions // ì²˜ë¦¬ëŸ‰ ì°¨íŠ¸ë„ max ì„¤ì •ì´ ì—†ëŠ” ê³µí†µ ì˜µì…˜ì„ ì‚¬ìš©
                });

                eventBus.subscribe('statsUpdated', ({ lbStats }) => this.update(lbStats));
                eventBus.subscribe('reset', () => this.reset());
            },

            update(lbStats) {
                const now = new Date().toLocaleTimeString();

                // [ìˆ˜ì •] updateChart í—¬í¼ í•¨ìˆ˜ë¥¼ ë‹¤ì‹œ ì‚¬ìš©í•˜ì—¬ ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.
                const updateChart = (chart, data) => {
                    if (!chart) return;
                    chart.data.labels.push(now);
                    chart.data.datasets[0].data.push(data);
                    if (chart.data.labels.length > config.maxChartPoints) {
                        chart.data.labels.shift();
                        chart.data.datasets[0].data.shift();
                    }
                    // Yì¶• maxë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì œì–´í•˜ëŠ” ëª¨ë“  ë¡œì§ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.
                    // Chart.jsê°€ ë°ì´í„°ì— ë§ì¶° ìë™ìœ¼ë¡œ ì¶•ì„ ë¦¬ì‚¬ì´ì§•í•˜ë„ë¡ í•©ë‹ˆë‹¤.
                    chart.update('none');
                };

                updateChart(this.charts.responseTime, lbStats?.load_balancer?.avg_response_time_ms || 0);
                updateChart(this.charts.throughput, lbStats?.load_balancer?.requests_per_second || 0);
            },

            reset() {
                // [ìˆ˜ì •] ë¦¬ì…‹ ì‹œ ì°¨íŠ¸ì˜ ë°ì´í„°ë§Œ ë¹„ì›ë‹ˆë‹¤.
                // Yì¶• max ì˜µì…˜ì„ ìˆ˜ë™ìœ¼ë¡œ ë¦¬ì…‹í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
                Object.values(this.charts).forEach(chart => {
                    if(chart) {
                        chart.data.labels = [];
                        chart.data.datasets[0].data = [];
                        chart.update();
                    }
                });
            }
        };

        const statusModule = {
            init() {
                eventBus.subscribe('statsUpdated', ({ lbStats, apiStats, isFetchSuccess }) => this.update(lbStats, apiStats, isFetchSuccess));
                eventBus.subscribe('fetchError', ({ isFetchSuccess }) => this.update(null, null, isFetchSuccess));
            },
            update(lbStats, apiStats, isFetchSuccess) {
                const elements = {
                    overallStatus: document.getElementById('overall-status'), activeServices: document.getElementById('active-services'),
                    totalRequests: document.getElementById('total-requests'), successRate: document.getElementById('success-rate'),
                    currentRps: document.getElementById('current-rps'), avgResponseTime: document.getElementById('avg-response-time'),
                    errorRate: document.getElementById('error-rate'), dbStatus: document.getElementById('db-status'),
                    cacheHitRate: document.getElementById('cache-hit-rate'), activeSessions: document.getElementById('active-sessions'),
                    serverList: document.getElementById('server-list'),
                };
                if (!isFetchSuccess) {
                    elements.overallStatus.textContent = 'DISCONNECTED';
                    elements.overallStatus.className = 'metric-value metric-danger';
                    this.updateServerList(null, elements.serverList, false);
                    return;
                }
                const lbData = lbStats.load_balancer;
                const healthData = lbStats.health_check;
                elements.totalRequests.textContent = (lbData?.total_requests || 0).toLocaleString();
                elements.successRate.textContent = `${(lbData?.success_rate || 0).toFixed(1)}%`;
                elements.currentRps.textContent = (lbData?.requests_per_second || 0).toFixed(1);
                elements.avgResponseTime.textContent = `${(lbData?.avg_response_time_ms || 0).toFixed(1)}ms`;
                elements.errorRate.textContent = `${(100 - (lbData?.success_rate || 100)).toFixed(1)}%`;
                const healthy = healthData?.healthy_servers || 0;
                const total = healthData?.total_servers || 0;
                elements.activeServices.textContent = `${healthy + 1}/${total + 1}`;
                const dbIsHealthy = apiStats?.database?.status === 'healthy';
                elements.dbStatus.textContent = dbIsHealthy ? 'ONLINE' : 'OFFLINE';
                elements.dbStatus.className = `metric-value ${dbIsHealthy ? 'metric-good' : 'metric-danger'}`;
                elements.cacheHitRate.textContent = `${(apiStats?.cache?.performance?.hit_rate || 0).toFixed(1)}%`;
                elements.activeSessions.textContent = apiStats?.auth?.total_active_sessions || 0;
                if (healthy < total) {
                    elements.overallStatus.textContent = 'DEGRADED';
                    elements.overallStatus.className = 'metric-value metric-danger';
                } else if ((lbData?.success_rate || 100) < 95) {
                    elements.overallStatus.textContent = 'WARNING';
                    elements.overallStatus.className = 'metric-value metric-warning';
                } else {
                    elements.overallStatus.textContent = 'HEALTHY';
                    elements.overallStatus.className = 'metric-value metric-good';
                }
                this.updateServerList(healthData?.server_details, elements.serverList, true);
            },
            updateServerList(serverDetails, serverListElement, isLbHealthy) {
                if (!serverListElement) return;
                serverListElement.innerHTML = '';
                const lbItem = document.createElement('li');
                lbItem.className = 'server-item';
                const lbStatusClass = isLbHealthy ? 'status-healthy' : 'status-error';
                lbItem.innerHTML = `<span><span class="status-indicator ${lbStatusClass}"></span>Load Balancer (7100)</span><span>${isLbHealthy ? 'Online' : 'Offline'}</span>`;
                serverListElement.appendChild(lbItem);
                if (!serverDetails) return;
                Object.entries(serverDetails).forEach(([server, stats]) => {
                    const li = document.createElement('li');
                    li.className = 'server-item';
                    const isHealthy = stats.healthy;
                    const statusClass = isHealthy ? 'status-healthy' : 'status-error';
                    const responseTime = stats.avg_response_time ? `${stats.avg_response_time.toFixed(1)}ms` : 'N/A';
                    li.innerHTML = `<span><span class="status-indicator ${statusClass}"></span>API Gateway (${server.split(':')[1]})</span><span>${isHealthy ? responseTime : 'Offline'}</span>`;
                    serverListElement.appendChild(li);
                });
            }
        };

        const alertModule = {
            init() {
                eventBus.subscribe('statsUpdated', ({ lbStats }) => this.checkAlerts(lbStats));
            },
            checkAlerts(lbStats) {
                const lbData = lbStats?.load_balancer;
                const healthData = lbStats?.health_check;
                if (!lbData || !healthData) return;
                const totalRequests = lbData.total_requests;
                const successRate = lbData.success_rate;
                const avgResponseTime = lbData.avg_response_time_ms;
                const healthy = healthData.healthy_servers;
                const total = healthData.total_servers;
                if (totalRequests > 0 && successRate !== undefined && successRate < 95) {
                    this.addAlert('warning', `Success rate is low: ${successRate.toFixed(1)}%`);
                }
                if (avgResponseTime !== undefined && avgResponseTime > 500) {
                    this.addAlert('warning', `High response time: ${avgResponseTime.toFixed(1)}ms`);
                }
                if (healthy !== undefined && total !== undefined && healthy < total) {
                    this.addAlert('error', `${total - healthy} backend server(s) are down.`);
                }
            },
            addAlert(type, message) {
                const container = document.getElementById('alerts-container');
                if (!container) return;
                const alert = document.createElement('li');
                alert.className = `alert-box ${type}`;
                alert.innerHTML = `<strong>${type.toUpperCase()}:</strong> ${message}`;
                container.insertBefore(alert, container.firstChild);
                if (container.children.length > config.maxAlerts) {
                    container.removeChild(container.lastChild);
                }
            }
        };

        const controlsModule = {
            init() {
                document.getElementById('toggle-monitoring-btn')?.addEventListener('click', this.toggleMonitoring);
                document.getElementById('refresh-btn')?.addEventListener('click', this.refresh);
                document.getElementById('reset-stats-btn')?.addEventListener('click', this.reset);
            },
            toggleMonitoring() {
                const btn = document.getElementById('toggle-monitoring-btn');
                apiService.monitoringEnabled = !apiService.monitoringEnabled;
                if (apiService.monitoringEnabled) {
                    btn.textContent = 'ëª¨ë‹ˆí„°ë§ ON';
                    btn.classList.add('active');
                    apiService.start();
                } else {
                    btn.textContent = 'ëª¨ë‹ˆí„°ë§ OFF';
                    btn.classList.remove('active');
                    apiService.stop();
                }
            },
            async reset() {
                eventBus.publish('log', { message: 'Resetting backend statistics...' });
                const success = await apiService.resetAllStats();
                if (success) {
                    eventBus.publish('log', { message: 'Statistics have been reset.' });
                    eventBus.publish('reset');
                    await apiService.fetchAllStats();
                } else {
                    eventBus.publish('log', { message: 'Failed to reset backend stats.', type: 'error' });
                }
            },
            refresh() {
                eventBus.publish('log', { message: 'Manual refresh triggered.' });
                apiService.fetchAllStats();
            }
        };

        const utilityModule = {
            startTime: Date.now(),
            init() {
                eventBus.subscribe('log', ({ message, type = 'info' }) => this.addLog(message, type));
                eventBus.subscribe('fetchError', ({ error }) => this.addLog(`[ERROR] ${error.message}`, 'error'));
                setInterval(() => this.updateTime(), 1000);
            },
            addLog(message, type = 'info') { const logsContainer = document.getElementById('logs-container'); if (!logsContainer) return; const logEntry = document.createElement('div'); logEntry.className = 'log-entry'; logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; logEntry.style.color = type === 'error' ? '#f87171' : '#ecf0f1'; logsContainer.insertBefore(logEntry, logsContainer.firstChild); if (logsContainer.children.length > config.maxLogEntries) logsContainer.removeChild(logsContainer.lastChild); },
            updateTime() { const uptimeElem = document.getElementById('uptime'); const timeElem = document.getElementById('current-time'); if (timeElem) timeElem.textContent = new Date().toLocaleString(); if (uptimeElem) { const uptime = Date.now() - this.startTime; const h = String(Math.floor(uptime / 3600000)).padStart(2, '0'); const m = String(Math.floor((uptime % 3600000) / 60000)).padStart(2, '0'); const s = String(Math.floor((uptime % 60000) / 1000)).padStart(2, '0'); uptimeElem.textContent = `Uptime: ${h}:${m}:${s}`; } }
        };

        function main() {
            chartModule.init();
            statusModule.init();
            alertModule.init();
            controlsModule.init();
            utilityModule.init();
            eventBus.publish('log', { message: 'Monitoring dashboard initialized.' });
            apiService.start();
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>
